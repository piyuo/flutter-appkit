import 'package:flutter/material.dart';
import 'package:libcli/i18n/i18n.dart' as i18n;
import 'package:libcli/pb/pb.dart' as pb;
import 'dataset.txt';
import 'data.txt';

class DataSource<T extends pb.Object> extends Dataset<T> with ChangeNotifier {
  DataSource({
    BuildContext? context,
    required String id,
    required DataLoader<T> dataLoader,
    required pb.Builder<T> dataBuilder,
    DataRemover<T>? dataRemover,
    this.onRowsChanged,
    this.autoSelectFirstRow = false,
    int rowsPerPage = 10,
  }) : super(
          id: id,
          dataLoader: dataLoader,
          dataBuilder: dataBuilder,
          dataRemover: dataRemover,
        ) {
    _rowsPerPage = rowsPerPage;
    if (context != null) {
      init(context);
    }
  }

  /// autoSelectFirstRow will auto select first row after init
  final bool autoSelectFirstRow;

  /// onRowsChange is called when rows are changed
  final VoidCallback? onRowsChanged;

  /// onRefreshBegin is called when data source begin to refresh
  VoidCallback? onRefreshBegin;

  /// onRefreshEnd is called when data source end to refresh
  VoidCallback? onRefreshEnd;

  /// _selectedRows keep all selected rows
  List<T> selectedRows = [];

  /// pageRows return current page rows
  List<T> get pageRows => rows.getRange(currentIndexStart, currentIndexEnd).toList();

  /// pageIndex return current page index
  int get pageIndex => _pageIndex;

  /// _rowsPerPage is current rows per page
  int _rowsPerPage = 10;

  /// rowsPerPage return current rows per page
  int get rowsPerPage => _rowsPerPage;

  /// _isLoading return true if data source is busy loading data
  bool _isLoading = false;

  /// isLoading return true if data source is busy loading data
  bool get isLoading => _isLoading;

  /// _pageIndex is current page index
  int _pageIndex = 0;

  /// pageCount return total page count
  int get pageCount {
    if (isEmpty) {
      return 1;
    }
    return (rows.length / _rowsPerPage).ceil();
  }

  /// currentIndexStart return start index in current page
  int get currentIndexStart => _pageIndex * _rowsPerPage;

  /// currentIndexEnd return end index in current page
  int get currentIndexEnd => currentIndexStart + currentRowCount;

  /// return row count in current page
  int get currentRowCount => getRowCountByPage(_pageIndex);

  /// isLastPage return true if current page is the last page
  bool get isLastPage => noMoreData && _pageIndex == pageCount - 1;

  /// hasFirstPage return true if user can click first page
  bool get hasFirstPage => hasPrevPage;

  /// hasPrevPage return true if user can click prev page
  bool get hasPrevPage => !_isLoading && _pageIndex > 0;

  /// hasLastPage return true if user can click last page
  bool get hasLastPage => !_isLoading && noMoreData && _pageIndex < pageCount - 1;

  /// hasNextPage return true if user can click next page
  bool get hasNextPage {
    if (_isLoading) {
      return false;
    }
    if (!noMoreData) {
      return true;
    }
    return _pageIndex < pageCount - 1;
  }

  /// init data source with cache or data loader
  ///
  ///     await init(context);
  ///
  @override
  Future<void> init(BuildContext context) async {
    await super.init(context);
    // may select first new item after refresh
    if (autoSelectFirstRow) {
      selectFirstRows();
    }
    // may select first new item after refresh
    await refreshData(context);
    if (autoSelectFirstRow) {
      selectFirstRows();
    }
  }

  /// _notifyLoading set busy value and notify listener
  void _notifyLoading(bool value) {
    if (value != _isLoading) {
      _isLoading = value;
      notifyListeners();
    }
  }

  /// onDataChanged called when data changed
  @visibleForTesting
  void onDataChanged() {
    // remove not exists selected rows
    for (int i = selectedRows.length - 1; i >= 0; i--) {
      final selected = selectedRows[i];
      if (!rows.contains(selected)) {
        selectedRows.remove(selected);
      }
    }
    onRowsChanged?.call();
  }

  /// nextPage return true if load data
  ///
  ///     await nextPage(context);
  ///
  Future<void> nextPage(BuildContext context) async => await gotoPage(context, _pageIndex + 1);

  /// prevPage return true if page changed
  ///
  ///     await prevPage(context);
  ///
  Future<void> prevPage(BuildContext context) async => await gotoPage(context, _pageIndex - 1);

  /// firstPage return true if page changed
  ///
  ///     await firstPage(context);
  ///
  Future<void> firstPage(BuildContext context) async => await gotoPage(context, 0);

  /// lastPage return true if page changed
  ///
  ///     await lastPage(context);
  ///
  Future<void> lastPage(BuildContext context) async => await gotoPage(context, pageCount - 1);

  /// gotoPage goto specified page, load more page if needed
  ///
  ///     await gotoPage(context,2);
  ///
  @visibleForTesting
  Future<void> gotoPage(BuildContext context, int index) async {
    _notifyLoading(true);
    try {
      final expectRowsCount = rows.length - index * _rowsPerPage;
      if (expectRowsCount < _rowsPerPage && !noMoreData) {
        //the page is not fill with enough data, load more data
        await more(context, _rowsPerPage - expectRowsCount);
      }
      _pageIndex = index;
      if (_pageIndex < 0) {
        _pageIndex = 0;
      }
      if (_pageIndex >= pageCount) {
        _pageIndex = pageCount - 1;
      }
    } finally {
      _notifyLoading(false);
    }
  }

  /// setRowsPerPage set rows per page and change page index to 0
  ///
  ///     await setRowsPerPage(context,20);
  ///
  Future<void> setRowsPerPage(BuildContext context, int value) async {
    _notifyLoading(true);
    try {
      _pageIndex = 0;
      _rowsPerPage = value;
      await gotoPage(context, 0);
    } finally {
      _notifyLoading(false);
    }
  }

  /// refreshData cached rows
  ///
  ///     await refreshData(context);
  ///
  Future<void> refreshData(BuildContext context) async {
    onRefreshBegin?.call();
    try {
      _pageIndex = 0;
      await refresh(context, _rowsPerPage);
    } finally {
      notifyListeners();
      onRefreshEnd?.call();
    }
  }

  /// getRowCountByPage return row total count in current page
  ///
  ///     sds.getRowCountByPage(0);
  ///
  @visibleForTesting
  int getRowCountByPage(int pageIndex) {
    if (pageIndex >= pageCount) {
      return 0; // page not exists
    }
    if (pageIndex == pageCount - 1) {
      return rows.length - pageIndex * _rowsPerPage;
    }
    return _rowsPerPage;
  }

  /// paging return text page info like '1-10' of 19
  String pagingInfo(BuildContext context) {
    if (noMoreData) {
      return '${currentIndexStart + 1} - $currentIndexEnd ' +
          context.i18n.pagingCount.replaceAll('%1', rows.length.toString());
    }
    return '${currentIndexStart + 1} - $currentIndexEnd ' + context.i18n.pagingMany;
  }

  /// isRowSelected return true when row is selected
  bool isRowSelected(T row) => selectedRows.contains(row);

  /// setSelectedRows select all row
  void setSelectedRows(List<T> value) {
    selectedRows = value;
    notifyListeners();
  }

  /// selectAllRows select all row
  void selectAllRows(bool selected) {
    selectedRows.clear();
    if (selected) {
      selectedRows.addAll(rows);
    }
    notifyListeners();
  }

  /// selectFirstRows select first row in current page
  void selectFirstRows() {
    if (rows.isNotEmpty) {
      selectedRows.clear();
      selectedRows.add(rows[0]);
      notifyListeners();
    }
  }

  /// selectPageRows select all row in current page
  void selectPageRows(bool selected) {
    selectedRows.clear();
    if (selected) {
      selectedRows.addAll(rows.getRange(currentIndexStart, currentIndexEnd));
    }
    notifyListeners();
  }

  /// selectRow select a row
  void selectRow(T row, bool? selected) {
    selected = selected ?? false;
    if (selected) {
      if (!selectedRows.contains(row)) {
        selectedRows.add(row);
      }
    } else {
      selectedRows.remove(row);
    }
    notifyListeners();
  }

  /// delete item from dataset
  Future<void> deleteSelectedRows(BuildContext context) async {
    if (selectedRows.isNotEmpty) {
      final ids = selectedRows.map((row) => row.entityID).toList();
      delete(context, ids);
    }
  }
}
