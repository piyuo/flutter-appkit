
  Widget _menu(BuildContext context) {
    final button = PopupMenuButton(
        onSelected: (value) {
          debugPrint('$value');
          // This offset should depend on the largest text and this is tricky when
          // the menu items are changed
          /*         Offset offset = Offset(-300, 0);

          final RenderBox button = context.findRenderObject() as RenderBox;
          final RenderBox overlay = Overlay.of(context).context.findRenderObject() as RenderBox;
          final RelativeRect position = RelativeRect.fromRect(
            Rect.fromPoints(
              button.localToGlobal(Offset.zero, ancestor: overlay),
              button.localToGlobal(button.size.bottomRight(Offset.zero), ancestor: overlay),
            ),
            offset & overlay.size,
          );
          showMenu(
            context: context,
            position: position,
            items: [
              PopupMenuItem(
                value: '1',
                child: const Text('item 1'),
              ),
              PopupMenuItem(
                value: '2',
                child: const Text('item 2'),
              ),
            ],
          );
*/
        },
        itemBuilder: (context) => [
              const PopupMenuItem(
                child: Text("First"),
                value: 1,
              ),
              const PopupMenuItem(
                child: Text("Second"),
                value: 2,
              ),
              const PopupSubMenuItem<int>(
                title: 'Other items',
                items: [100, 200, 300, 400, 500],
              ),
            ]);
    return Column(children: [button]);
  }



/// An item with sub menu for using in popup menus
///
/// [title] is the text which will be displayed in the pop up
/// [items] is the list of items to populate the sub menu
/// [onSelected] is the callback to be fired if specific item is pressed
///
/// Selecting items from the submenu will automatically close the parent menu
/// Closing the sub menu by clicking outside of it, will automatically close the parent menu
class PopupSubMenuItem<T> extends PopupMenuEntry<T> {
  const PopupSubMenuItem({
    required this.title,
    required this.items,
    this.onSelected,
    Key? key,
  }) : super(key: key);

  final String title;
  final List<T> items;
  final Function(T)? onSelected;

  @override
  double get height => kMinInteractiveDimension; //Does not actually affect anything

  @override
  bool represents(T? value) => false; //Our submenu does not represent any specific value for the parent menu

  @override
  State createState() => _PopupSubMenuState<T>();
}

/// The [State] for [PopupSubMenuItemX] subclasses.
class _PopupSubMenuState<T> extends State<PopupSubMenuItem<T>> {
  @override
  Widget build(BuildContext context) {
    return PopupMenuItem(
        onTap: () async {
          debugPrint('hello');
          Offset offset = Offset(0, 0);
          final RenderBox button = context.findRenderObject() as RenderBox;
          var offset2 = button.localToGlobal(Offset.zero);
          final pos = Rect.fromLTWH(offset.dx, offset.dy, button.size.width, button.size.height);

          final RenderBox overlay = Overlay.of(context)!.context.findRenderObject() as RenderBox;
          final RelativeRect position = RelativeRect.fromRect(
            Rect.fromPoints(
              button.localToGlobal(Offset.zero, ancestor: overlay),
              button.localToGlobal(button.size.bottomRight(Offset.zero), ancestor: overlay),
            ),
            offset & overlay.size,
          );

//          double left = offset.dx;
          //        double top = offset.dy;
          await showMenu(
              context: context,
              position: position,
              items: widget.items
                  .map(
                    (item) => PopupMenuItem<T>(
                        value: item,
                        child: Text(item
                            .toString()) //MEthod toString() of class T should be overridden to repesent something meaningful
                        ),
                  )
                  .toList());
        },
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.max,
          children: <Widget>[
            Expanded(
              child: Text(widget.title),
            ),
            Icon(
              Icons.chevron_right,
              size: 24.0,
              color: Theme.of(context).iconTheme.color,
            ),
          ],
        ));

    return PopupMenuButton<T>(
      tooltip: widget.title,
      child: Padding(
        padding: const EdgeInsets.only(left: 16.0, right: 8.0, top: 12.0, bottom: 12.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.max,
          children: <Widget>[
            Expanded(
              child: Text(widget.title),
            ),
            Icon(
              Icons.chevron_right,
              size: 24.0,
              color: Theme.of(context).iconTheme.color,
            ),
          ],
        ),
      ),
      onCanceled: () {
        if (Navigator.canPop(context)) {
          Navigator.pop(context);
        }
      },
      onSelected: (T value) {
        if (Navigator.canPop(context)) {
          Navigator.pop(context, value);
        }
        //widget.onSelected?.call(value);
      },
      offset: Offset(8, 0),
      itemBuilder: (BuildContext context) {
        return widget.items
            .map(
              (item) => PopupMenuItem<T>(
                  value: item,
                  child: Text(item
                      .toString()) //MEthod toString() of class T should be overridden to repesent something meaningful
                  ),
            )
            .toList();
      },
    );
  }
}



/*
/// An item with sub menu for using in popup menus
///
/// [title] is the text which will be displayed in the pop up
/// [items] is the list of items to populate the sub menu
/// [onSelected] is the callback to be fired if specific item is pressed
///
/// Selecting items from the submenu will automatically close the parent menu
/// Closing the sub menu by clicking outside of it, will automatically close the parent menu
class PopupSubMenuItemX<T> extends PopupMenuEntry<T> {
  const PopupSubMenuItemX({
    required this.title,
    required this.items,
    this.onSelected,
    Key? key,
  }) : super(key: key);

  final String title;
  final List<T> items;
  final Function(T)? onSelected;

  @override
  double get height => kMinInteractiveDimension; //Does not actually affect anything

  @override
  bool represents(T? value) => false; //Our submenu does not represent any specific value for the parent menu

  @override
  State createState() => _PopupSubMenuStateX<T>();
}

/// The [State] for [PopupSubMenuItemX] subclasses.
class _PopupSubMenuStateX<T> extends State<PopupSubMenuItemX<T>> {
  @override
  Widget build(BuildContext context) {
    return ChildSizeNotifier(
      builder: (context, size, child) {
        // size is the size of the text
        return PopupMenuButton<T>(
          tooltip: widget.title,
          child: Padding(
            padding: const EdgeInsets.only(left: 16.0, right: 8.0, top: 12.0, bottom: 12.0),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              mainAxisSize: MainAxisSize.max,
              children: <Widget>[
                Expanded(
                  child: Text(widget.title),
                ),
                Icon(
                  Icons.chevron_right,
                  size: 24.0,
                  color: Theme.of(context).iconTheme.color,
                ),
              ],
            ),
          ),
          onCanceled: () {
            if (Navigator.canPop(context)) {
              Navigator.pop(context);
            }
          },
          onSelected: (T value) {
            if (Navigator.canPop(context)) {
              Navigator.pop(context, value);
            }
            //widget.onSelected?.call(value);
          },
          offset: Offset(8, 0),
          itemBuilder: (BuildContext context) {
            return widget.items
                .map(
                  (item) => PopupMenuItem<T>(
                      value: item,
                      child: Text(item
                          .toString()) //MEthod toString() of class T should be overridden to repesent something meaningful
                      ),
                )
                .toList();
          },
        );
      },
    );
  }
}

class ChildSizeNotifier extends StatelessWidget {
  final ValueNotifier<Size> notifier = ValueNotifier(const Size(0, 0));
  final Widget Function(BuildContext context, Size size, Widget? child) builder;
  final Widget? child;

  ChildSizeNotifier({
    Key? key,
    required this.builder,
    this.child,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    WidgetsBinding.instance!.addPostFrameCallback(
      (_) {
        notifier.value = (context.findRenderObject() as RenderBox).size;
      },
    );
    return ValueListenableBuilder(
      valueListenable: notifier,
      builder: builder,
      child: child,
    );
  }
}
*/