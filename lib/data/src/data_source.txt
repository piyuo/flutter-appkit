import 'package:flutter/material.dart';
import 'package:libcli/i18n/i18n.dart' as i18n;
import 'package:libcli/pb/pb.dart' as pb;
import 'dataset.dart';

class DataSource<T extends pb.Object> extends ChangeNotifier {
  DataSource({
    required String id,
    required DataLoader<T> dataLoader,
  }) {
    _dataset = Dataset(id: id, dataLoader: dataLoader);
  }

  /// _rows keep all cached rows
  late Dataset<T> _dataset;

  /// _selectedRows keep all selected rows
  final List<T> _selectedRows = [];

  /// currentRows export cached rows for Test
  Iterable<T> get rows => _dataset.rows.getRange(_pageIndex, _pageIndex + rowsPerPage);

  /// _rowsPerPage is current rows per page
  int _rowsPerPage = 10;

  /// _isBusy return true if data source is busy loading data
  bool _isBusy = false;

  /// _pageIndex is current page index
  int _pageIndex = 0;

  /// pageCount return total page count
  int get pageCount {
    if (_dataset.isEmpty) {
      return 1;
    }
    return (_dataset.length / _rowsPerPage).ceil();
  }

  /// isLastPage return true if current page is last page
  bool get isLastPage => _dataset.noMoreData || _pageIndex == pageCount - 1;

  /// _notifyBusy set busy value and notify listener
  void _notifyBusy(bool value) {
    if (value != _isBusy) {
      _isBusy = value;
      notifyListeners();
    }
  }

  /// _ensureSelectedRowsExists remove selected rows if it not exists in rows
  void _ensureSelectedRowsExists() {
    for (int i = _selectedRows.length - 1; i >= 0; i--) {
      final selected = _selectedRows[i];
      if (!_dataset.contains(selected)) {
        _selectedRows.remove(selected);
      }
    }
  }

  /// init data source with cache or data loader
  ///
  ///     await init(context);
  ///
  Future<void> init(BuildContext context) async {
    _notifyBusy(true);
    try {
      await _dataset.init();
      await _dataset.refresh(context, _rowsPerPage);
    } finally {
      _notifyBusy(false);
    }
  }

  /// hasFirstPage return true if user can click first page
  bool get hasFirstPage => hasPrevPage;

  /// hasPrevPage return true if user can click prev page
  bool get hasPrevPage => !_isBusy && _pageIndex > 0;

  /// hasLastPage return true if user can click last page
  bool get hasLastPage => !_isBusy && _dataset.noMoreData && _pageIndex < pageCount - 1;

  /// hasNextPage return true if user can click next page
  bool get hasNextPage {
    if (_isBusy) {
      return false;
    }
    if (!_dataset.noMoreData) {
      return true;
    }
    return _pageIndex < pageCount - 1;
  }

  /// nextPage return true if load data
  ///
  ///     await nextPage(context);
  ///
  Future<void> nextPage(BuildContext context) async {
    await loadMoreRow(context, to: _pageIndex + 1);
    _pageIndex++;
    if (_pageIndex >= pageCount) {
      _pageIndex = pageCount - 1;
    }
    notifyListeners();
  }

  /// prevPage return true if page changed
  ///
  ///     final changed = await prevPage(context);
  ///
  Future<bool> prevPage(BuildContext context) async {
    if (_pageIndex > 0) {
      _pageIndex--;
      notifyListeners();
      return true;
    }
    return false;
  }

  /// firstPage return true if page changed
  ///
  ///     final changed = await firstPage(context);
  ///
  Future<bool> firstPage(BuildContext context) async {
    if (_pageIndex > 0) {
      _pageIndex = 0;
      notifyListeners();
      return true;
    }
    return false;
  }

  /// lastPage return true if page changed
  ///
  ///     final changed = await lastPage(context);
  ///
  Future<bool> lastPage(BuildContext context) async {
    if (_pageIndex < pageCount - 1) {
      _pageIndex = pageCount - 1;
      notifyListeners();
      return true;
    }
    return false;
  }

  /// loadMoreRow load more row after current rows to toPageIndex
  ///
  ///     await loadMoreRow(context,2);
  ///
  Future<void> loadMoreRow(BuildContext context, {int? to}) async {
    _notifyBusy(true);
    try {
      if (status == PagedDataSourceStatus.end) {
        return;
      }

      to = to ?? _pageIndex;
      assert(to >= 0, 'page index can not small than zero');
      var diff = ((to + 1) * _rowsPerPage) - _rows.length;
      if (diff == 0) {
        return;
      }

      final last = _rows.isEmpty ? null : _rows[_rows.length - 1];
      final list = await dataLoader(context, last, diff);
      assert(list.length <= diff, 'data loader load too much data, maxCount is $diff');
      status = list.length < diff ? PagedDataSourceStatus.end : PagedDataSourceStatus.load;
      _rows.addAll(list);
      await saveToCache(context);
      debugPrint('load page $to with ${list.length} row');
    } finally {
      _notifyBusy(false);
    }
  }

  /// refreshNewRow refresh cached rows
  ///
  ///     await refreshNewRow(context);
  ///
  Future<void> refreshNewRow(BuildContext context) async {
    if (!supportRefresh) {
      return;
    }
    _notifyBusy(true);
    try {
      T? first = _rows.isNotEmpty ? _rows[0] : null;
      final instruction = await dataRefresher!(context, first, _rowsPerPage);
      if (instruction.updated.length == _rowsPerPage) {
        _selectedRows.clear();
        _rows.clear();
        _rows.addAll(instruction.updated);
        status = PagedDataSourceStatus.load;
        _pageIndex = 0;
        await saveToCache(context);
        debugPrint('refresh all');
        return;
      }

      if (instruction.isNotEmpty) {
        deleteRows(instruction.deleted);
        deleteRows(instruction.updated);
        _rows.insertAll(0, instruction.updated);
        if (_pageIndex > pageCount - 1) {
          _pageIndex = pageCount - 1;
        }
        if (status == PagedDataSourceStatus.notLoad) {
          status = PagedDataSourceStatus.load;
        }
        _ensureSelectedRowsExists();
        await saveToCache(context);
        debugPrint('refreshed');
      }
    } finally {
      _notifyBusy(false);
    }
  }

  /// rowCount return current page row count
  ///
  ///     dataSource.rowCount;
  ///
  int get rowCount => getRowCountByPage(_pageIndex);

  /// getRowCountByPage return row total count in current page
  ///
  ///     sds.getRowCountByPage(0);
  ///
  @visibleForTesting
  int getRowCountByPage(int pageIndex) {
    if (pageIndex >= pageCount) {
      return 0; // page not exists
    }
    if (pageIndex == pageCount - 1) {
      return _rows.length - pageIndex * _rowsPerPage;
    }
    return _rowsPerPage;
  }

  /// rowIndex get real row index from current page and position
  ///
  ///     sds.currentPageRow(0,0);
  ///
  int rowIndex(int row) => getRowIndexByPage(_pageIndex, row);

  /// getRowIndexByPage return a row index in page
  ///
  ///     getRowIndexByPage(0,0);
  ///
  @visibleForTesting
  int getRowIndexByPage(int pageIndex, int position) => pageIndex * _rowsPerPage + position;

  /// row return a row by row index
  ///
  ///     sds.row(1);
  ///
  T? row(int rowIndex) => rowIndex < _rows.length ? _rows[rowIndex] : null;

  /// supportRefresh return true if support refresh
  bool get supportRefresh => dataRefresher != null && dataComparator != null && loaded;

  /// supportRemove return true if support remove selected rows
  bool get supportRemove => dataRemover != null && loaded;

  /// rowsPerPage return current rows per page
  int get rowsPerPage => _rowsPerPage;

  /// setRowsPerPage set rows per page and change page index to 0
  ///
  ///     await setRowsPerPage(context,20);
  ///
  Future<void> setRowsPerPage(BuildContext context, value) async {
    _pageIndex = 0;
    _rowsPerPage = value;
    await loadMoreRow(context);
    await saveToCache(context); // may need save when rowsPerPage changed
  }

  /// paging return text page info like '1-10' of 19
  String pagingInfo(BuildContext context) {
    if (status == PagedDataSourceStatus.notLoad) {
      return '';
    }
    int start = _pageIndex * _rowsPerPage;
    int end = start + getRowCountByPage(_pageIndex);
    if (status == PagedDataSourceStatus.end) {
      return '${start + 1} - $end ' + context.i18n.pagingCount.replaceAll('%1', _rows.length.toString());
    }
    return '${start + 1} - $end ' + context.i18n.pagingMany;
  }

  /// selectAll select all row
  void selectAll(bool? selected) {
    selected = selected ?? false;
    _selectedRows.clear();
    if (selected) {
      _selectedRows.addAll(_rows);
    }
    notifyListeners();
  }

  /// select a row
  void select(int rowIndex, bool? selected) {
    selected = selected ?? false;
    final row = _rows[rowIndex];
    if (selected) {
      if (!_selectedRows.contains(row)) {
        _selectedRows.add(row);
      }
    } else {
      _selectedRows.remove(row);
    }
    notifyListeners();
  }

  /// selectedRowsIsEmpty return true when selected rows is empty
  bool get selectedRowsIsEmpty => _selectedRows.isEmpty;

  /// selectedRowsLength return selected rows length
  int get selectedRowsLength => _selectedRows.length;

  /// isSelected return true when row is selected
  bool isSelected(int rowIndex) {
    final row = _rows[rowIndex];
    return _selectedRows.contains(row);
  }
}
