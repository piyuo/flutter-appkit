// ignore_for_file: invalid_use_of_visible_for_testing_member

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:libcli/pb/pb.dart' as pb;
import 'package:libcli/i18n/i18n.dart' as i18n;
import 'dataset.dart';
import 'cache.dart';

/// maxResetItem is the maximum number of items to delete in reset, rest leave to cache cleanup to avoid application busy too long.
int get maxResetItem => kIsWeb ? 50 : 500; // web is slow, clean 50 may tak 3 sec. native is much faster

/// _keyAll is key for keep all rows
const _keyAll = '__all';

/// _keyRowsPerPage is key for keep all rows per page
const _keyRowsPerPage = '__rpp';

/// _keyNoMoreData is key for no more data
const _keyNoMoreData = '__nmd';

/// deleteDatasetCache delete dataset cache
Future<void> deleteDatasetCache(String id) async {
  final all = getStringList('$id$_keyAll');
  if (all != null) {
    for (String id in all) {
      await delete(id);
    }
    await delete('$id$_keyAll');
    await delete('$id$_keyRowsPerPage');
    await delete('$id$_keyNoMoreData');
  }
  debugPrint('[dataset_cache] $id deleted');
}

/// DatasetCache is a range of data in local, no data allow to be deleted due to local cache can not detect server delete data
class DatasetCache<T extends pb.Object> extends Dataset<T> {
  DatasetCache({
    BuildContext? context,
    required this.id,
    required pb.Builder<T> dataBuilder,
    required DatasetLoader<T> loader,
  }) : super(context: context, dataBuilder: dataBuilder, loader: loader);

  /// id is the unique id of this dataset, it is used to cache data
  final String id;

  /// clear all data, we need clean all data when refresh indicate our cache is invalid
  @override
  Future<void> clear() async {
    final deletedRows = allRows;
    allRows = [];
    await delete('$id$_keyAll');
    int deleteCount = 0;
    for (String id in deletedRows) {
      await delete(id);
      deleteCount++;
      if (deleteCount >= maxResetItem) {
        break;
      }
    }
    await super.clear();
    debugPrint('[dataset_cache] clear');
  }

  /// open database
  @override
  Future<void> open() async {
    allRows = getStringList('$id$_keyAll') ?? [];
    rowsPerPage = getInt('$id$_keyRowsPerPage') ?? 10;
    noMoreData = getBool('$id$_keyNoMoreData') ?? false;
  }

  /// _save state into cache
  Future<void> _save() async {
    await setStringList('$id$_keyAll', allRows.map((row) => row as String).toList());
    await setInt('$id$_keyRowsPerPage', rowsPerPage);
    await setBool('$id$_keyNoMoreData', noMoreData);
  }

  /// onrRefresh return true if got new data
  @override
  Future<bool> onRefresh(BuildContext context) async {
    T? anchor = allRows.isNotEmpty ? getObject(allRows.first, dataBuilder) : null;
    final downloadRows = await loader(context, true, rowsPerPage, anchor?.entityUpdateTime, anchor?.entityID);
    if (allRows.isEmpty && downloadRows.length < rowsPerPage) {
      noMoreData = true;
    }

    if (downloadRows.isNotEmpty) {
      debugPrint('[dataset_cache] refresh ${downloadRows.length} rows');
      if (downloadRows.length == rowsPerPage) {
        // if download length == limit, it means there is more data and we need expired all our cache to start over
        await clear();
      }

      final downloadID = downloadRows.map((row) => row.entityID).toList();
      allRows.removeWhere((element) => downloadID.contains(element));
      allRows.insertAll(0, downloadID);
      await _save();

      for (T row in downloadRows) {
        await setObject(row.entityID, row);
      }
      return true;
    }
    return false;
  }

  /// onMore called when load more data
  @override
  Future<void> onMore(BuildContext context, int limit) async {
    T? anchor = allRows.isNotEmpty ? getObject(allRows.last, dataBuilder) : null;
    final downloadRows = await loader(context, false, limit, anchor?.entityUpdateTime, anchor?.entityID);
    if (downloadRows.length < limit) {
      debugPrint('[dataset_cache] has no more data');
      noMoreData = true;
    }

    final downloadID = downloadRows.map((row) => row.entityID).toList();
    allRows.addAll(downloadID);
    await _save();
    for (T row in downloadRows) {
      await setObject(row.entityID, row);
    }
  }

  /// hasNextPage return true if user can click next page
  @override
  bool get hasNextPage => noMoreData ? super.hasNextPage : true;

  /// hasLastPage return true if user can click last page
  @override
  bool get hasLastPage => noMoreData ? super.hasLastPage : false;

  /// ```dart
  /// await gotoPage(context, 2);
  /// ```
  @visibleForTesting
  @override
  Future<void> gotoPage(BuildContext context, int index) async {
    final expectRowsCount = allRows.length - index * rowsPerPage;
    if (expectRowsCount < rowsPerPage && !noMoreData) {
      //the page is not fill with enough data, load more data
      await more(context, rowsPerPage - expectRowsCount);
    }
    await super.gotoPage(context, index);
  }

  /// pagingInfo return text page info like '1-10 of 19'
  @override
  String pagingInfo(BuildContext context) {
    if (!noMoreData) {
      return '${currentIndexStart + 1} - $currentIndexEnd ' + context.i18n.pagingMany;
    }
    return super.pagingInfo(context);
  }

  /// fetch return list of object base on list of id
  @override
  Future<List<T>> fetch(List<dynamic> list) async {
    List<T> source = [];
    for (String id in list) {
      final row = getObject(id, dataBuilder);
      if (row == null) {
        // data is missing
        allRows = [];
        await _save();
        state = DatasetState.dataMissing;
        return [];
      }
      source.add(row);
    }
    return source;
  }
}
